<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="程序猿的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="程序猿的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序猿的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>程序猿的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序猿的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/25/ScheduledThreadPoolExecutor源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/ScheduledThreadPoolExecutor源码解析/" itemprop="url">ScheduledThreadPoolExecutor源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T20:37:54+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ScheduledThreadPoolExecutor继承了ThreadPoolExecutor和实现了ScheduledExecutorService接口。是用于执行延时任务和定时任务的线程池。</p>
<p>ScheduledThreadPoolExecutor的定期执行的实现是通过队列DelayedWorkQueue和ScheduledFutureTask来实现。将任务加入DelayedWorkQueue，按时间进行排序。先执行的先出队，没有到执行时间的任务就进行阻塞。</p>
<h1 id="核心内部类"><a href="#核心内部类" class="headerlink" title="核心内部类"></a>核心内部类</h1><h2 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h2><p>ScheduledFutureTask用于封装定期任务和获取任务结果。通过scheduled方法调用的任务最终都会封装成一个ScheduledFutureTask对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">            <span class="keyword">super</span>(r, result);</span><br><span class="line">            <span class="keyword">this</span>.time = ns;</span><br><span class="line">            <span class="keyword">this</span>.period = period;</span><br><span class="line">            <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ScheduledFutureTask的继承关系"><a href="#ScheduledFutureTask的继承关系" class="headerlink" title="ScheduledFutureTask的继承关系"></a>ScheduledFutureTask的继承关系</h3><p><img src="https://github.com/wujiazhen2/pict/blob/master/thread/ScheduledFutureTask.png" alt="ScheduledFutureTask的继承关系"></p>
<p>看继承关系可以看到，父接口有一个Delayed接口。Delayed接口继承了Comparable接口。DelayedWorkQueue队列种会根据compareTo种的排序规矩给队列元素排序。下面是实现方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还需要延迟多久</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按预定的执行时间排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h2><p>用于存储延迟执行的任务的阻塞队列。内部用数组实现,初始容量16。容量不足时会扩容50%。<br>queue数组表示一个二叉堆。</p>
<blockquote>
<p>当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值<br>总是小于或等于任何一个子节点的键值时为最小堆<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =</span><br><span class="line">           <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;x;</span><br><span class="line"> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"> lock.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">int</span> i = size;</span><br><span class="line">     <span class="comment">//1. 判断队列容量是否大于等于数组容量，是则需要扩容</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        <span class="comment">//2. 扩容，每次扩容50%</span></span><br><span class="line">         grow();</span><br><span class="line">    <span class="comment">//3. 队列容量+1</span></span><br><span class="line">     size = i + <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//4. 队列中还没有元素</span></span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//5. 加入第一个元素</span></span><br><span class="line">         queue[<span class="number">0</span>] = e;</span><br><span class="line">         setIndex(e, <span class="number">0</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//6. 队列中已经有元素就需要进行排序。</span></span><br><span class="line">         siftUp(i, e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//7. 如果队头元素等于新的元素e，说明e执行时间比队列中其他元素早，唤醒消费线程，消费线程判断元素e是否达到执行时间。</span></span><br><span class="line">     <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">         leader = <span class="keyword">null</span>;</span><br><span class="line">         available.signal();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组queue是一个二叉堆，新加入的元素通过堆排序找到合适的位置插入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//父节点</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class="line">        <span class="comment">//如果比父节点大，确定位置</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//如果比父节点小，和父节点交换位置，再和父节点的父节点比较。</span></span><br><span class="line">        queue[k] = e;</span><br><span class="line">        setIndex(e, k);</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>queue数组表示二叉堆，queue[0]元素是根节点。每次出队都是出跟节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">           <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">           lock.lockInterruptibly();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   <span class="comment">//1. 获取队头节点</span></span><br><span class="line">                   RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">                   <span class="comment">//2. 队头为空，没元素。进行等待。</span></span><br><span class="line">                   <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                       available.await();</span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       </span><br><span class="line">                       <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                       <span class="comment">//3.判断队头节点是否到了执行时间</span></span><br><span class="line">                       <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                           <span class="keyword">return</span> finishPoll(first); <span class="comment">//4. 返回队头节点，queue堆重新排列</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">//4.队头节点没到执行时间，进入等待</span></span><br><span class="line">                       first = <span class="keyword">null</span>; </span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">//这里是leader-follower模式的变种。为了减少不必要的等待。不是leader的线程会进行永久的等待直到被唤醒。leader线程只会等待到下个个延迟。</span></span><br><span class="line">                       <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                           available.await();</span><br><span class="line">                       <span class="keyword">else</span> &#123;</span><br><span class="line">                           Thread thisThread = Thread.currentThread();</span><br><span class="line">                           leader = thisThread;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               available.awaitNanos(delay);</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                   leader = <span class="keyword">null</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">                   available.signal();</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ScheduledThreadPoolExecutor任务执行流程"><a href="#ScheduledThreadPoolExecutor任务执行流程" class="headerlink" title="ScheduledThreadPoolExecutor任务执行流程"></a>ScheduledThreadPoolExecutor任务执行流程</h1><h2 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h2><p>ScheduledThreadPoolExecutor的schedule方法很多，都差不多。以scheduleAtFiexedRate为例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> period,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="comment">//1. 将任务封装成ScheduledFutureTask </span></span><br><span class="line">       ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">           <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                         <span class="keyword">null</span>,</span><br><span class="line">                                         <span class="comment">//triggerTime方法会算出触发的具体时间，now()+initalDelay</span></span><br><span class="line">                                         triggerTime(initialDelay, unit),</span><br><span class="line">                                         unit.toNanos(period));</span><br><span class="line">       RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">       <span class="comment">//用outerTask保存当前任务。用于周期执行时，再次将任务加入队列。</span></span><br><span class="line">       sft.outerTask = t;</span><br><span class="line">       <span class="comment">//延迟执行，将任务加入到DelayedWorkQueue队列中。</span></span><br><span class="line">       delayedExecute(t);</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>执行任务时调用ThreadPoolExecutor的runWorker方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">       Thread wt = Thread.currentThread();</span><br><span class="line">       Runnable task = w.firstTask;</span><br><span class="line">       w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">       w.unlock(); </span><br><span class="line">       <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.通过getTask方法从队列中拿出一个任务。获取任务会阻塞</span></span><br><span class="line">           <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               w.lock();</span><br><span class="line">               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                   !wt.isInterrupted())</span><br><span class="line">                   wt.interrupt();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   beforeExecute(wt, task);</span><br><span class="line">                   Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//2. 调用任务的run方法</span></span><br><span class="line">                       task.run();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       afterExecute(task, thrown);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   task = <span class="keyword">null</span>;</span><br><span class="line">                   w.completedTasks++;</span><br><span class="line">                   w.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           processWorkerExit(w, completedAbruptly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>ScheduledFutureTask的run方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//是否周期任务，period&gt;0</span></span><br><span class="line">            <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">            <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">                cancel(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">                ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">                <span class="comment">//周期任务，设置下次执行的时间</span></span><br><span class="line">                setNextRunTime();</span><br><span class="line">                <span class="comment">//再将outerTask（任务提交时将自身赋值给了outerTask）加入任务队列。</span></span><br><span class="line">                reExecutePeriodic(outerTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/25/线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/线程池/" itemprop="url">线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T09:51:07+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><p>线程的创建和销毁会带来系统的开销。通过线程池进行线程的管理，可以进行线程的复用，避免线程频繁的创建和消耗。</p>
<blockquote>
<p>《java并发编程的艺术》 合理利用线程池能够带来三个好处 </p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</li>
</ol>
</blockquote>
<h1 id="线程池的属性"><a href="#线程池的属性" class="headerlink" title="线程池的属性"></a>线程池的属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="线程池的大小"><a href="#线程池的大小" class="headerlink" title="线程池的大小"></a>线程池的大小</h2><p>线程池的大小有三种。</p>
<ol>
<li><p>当前线程池大小<br>当前线程池中的线程数量</p>
</li>
<li><p>核心线程池大小 corePoolSize<br>线程池提交一个任务。如果当前线程数量&lt;corePoolSize，即使存在空闲线程可以执行任务也会创建一个新的线程。prestartAllCoreThreads方法可以提前创建并启动所有核心线程。</p>
</li>
<li><p>最大线程池大小 maxumumPoolSize<br>线程池允许创建的最大线程数。如果任务队列满了，且当前的线程数小于最大线程池大小，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</p>
</li>
</ol>
<h2 id="线程存活时间-keepAliveTime"><a href="#线程存活时间-keepAliveTime" class="headerlink" title="线程存活时间 keepAliveTime"></a>线程存活时间 keepAliveTime</h2><p>线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p>
<h2 id="工作队列-workQueue"><a href="#工作队列-workQueue" class="headerlink" title="工作队列 workQueue"></a>工作队列 workQueue</h2><p>用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。<br>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。<br>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。<br>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p>
<h2 id="线程工厂-threadFactory"><a href="#线程工厂-threadFactory" class="headerlink" title="线程工厂 threadFactory"></a>线程工厂 threadFactory</h2><p>用于创建线程的工厂</p>
<h2 id="拒绝策略-handler"><a href="#拒绝策略-handler" class="headerlink" title="拒绝策略 handler"></a>拒绝策略 handler</h2><p>工作队列满了和线程池大小已经达到最大线程池大小时，说明线程池已经饱和，任务无法处理。这时通过拒绝策列处理任务。<br>JDK1.5提供的四种策略。<br>AbortPolicy：直接抛出异常。<br>CallerRunsPolicy：用调用者所在线程来运行任务。<br>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。<br>DiscardPolicy：丢弃当前任务。<br>可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略</p>
<h1 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h1><p><img src="https://github.com/wujiazhen2/pict/blob/master/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.png?raw=true" alt="任务提交流程"></p>
<ol>
<li>向线程池提交任务</li>
<li>判断当前线程池大小是否大于核心线程池大小。如果当前线程池大小大于核心线程池大小则执行步骤3，否则创建线程执行任务。</li>
<li>判断工作队列是否已满。已满则继续执行步骤4，否则将任务加入工作队列，等待线程池中线程读取队列，执行任务。</li>
<li>判断当前线程池大小是否大于最大线程池大小。如果当前线程池大小大于最大线程池大小则执行步骤5，否则创建线程执行任务。</li>
<li>线程池饱和，执行拒绝策列RejectedExecutionHandler.rejectedExecution。</li>
</ol>
<h1 id="关闭线程池-shutdown和shutdownNow"><a href="#关闭线程池-shutdown和shutdownNow" class="headerlink" title="关闭线程池 shutdown和shutdownNow"></a>关闭线程池 shutdown和shutdownNow</h1><p>shutdown:设置线程池状态为SHUTDOWN，中断所有没有执行任务的线程。此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。<br>shutdownNow:设置线程池状态为STOP，尝试停止所有正在执行任务或暂停任务的线程（通过interrupt）。shutdownNow并不代表线程池就一定立即就能退出，<code>（因为任务如果没有处于阻塞等待状态，interrupt无法中断）</code>它可能必须要等待所有正在执行的任务都执行完成了才能退出。 </p>
<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><p>Thread即使工作单元也是执行机制。从jdk5起把工作单元和执行机制分开。工作单元是Runnable，Callable，执行机制由Executor框架提供。</p>
<h2 id="Executor框架组成"><a href="#Executor框架组成" class="headerlink" title="Executor框架组成"></a>Executor框架组成</h2><ol>
<li>任务 实现Runnable和Callable接口</li>
<li>执行机制 实现Executor接口。主要实现类由ThreadPoolExecutor和ScheduledThreadPoolExecutor。</li>
<li>异步计算结果 实现Future接口</li>
<li>Executors工具类 </li>
</ol>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor是线程池的实现。构造函数的参数前面已经介绍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Executors工具类提供创建ThreadPoolExecutor的方法。</p>
<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个可缓存的线程池。可以从ThreadPoolExecutor的构造函数参数看出它的功能。核心线程池大小0，最大线程池大小Integer.MAX_VALUE,使用不存储元素的阻塞队列SynchronousQueue。所以CachedThreadPool的线程池大小几乎无限大，提交任务时如果没有空闲的线程<code>(没线程读取SynchronousQueue)</code>就会创建一个线程。工作线程闲置60s，将会被终止。</p>
<p>适用：适合于大量执行时间短的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool,固定大小的线程池。核心线程池大小和最大线程池大小一致。线程存活时间为0意味着空闲线程池不会被终止。提交任务时，都会创建一个线程。直到线程数达到指定的线程数nThreads，才会将任务放入队列。LinkedBlockingQueue时有界的阻塞队列，默认大小时Integer.MAX_VALUE。</p>
<p>适用：执行长期的任务，负载比较重的服务器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor,单线程的线程池。线程池大小只能是1.</p>
<p>适用：按顺序执行任务，且任何时间的不会有多个线程是活动的情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>线程池执行任务提供了2个方法 execute和submit</p>
<p>execute方法执行任务，没返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>submit方法有返回值Future,通过Future对象可以获取返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;String&gt; submit = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"run"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//阻塞获取返回值</span></span><br><span class="line">System.out.println(submit.get());</span><br></pre></td></tr></table></figure></p>
<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor继承了ThreadPoolExecutor和实现了ScheduledExecutorService接口。是用于执行延时任务和周期任务的线程池。功能与Timer类似。Timer是单线程，ScheduledThreadPoolExecutor是多线程。</p>
<h3 id="ScheduledExecutorService-API"><a href="#ScheduledExecutorService-API" class="headerlink" title="ScheduledExecutorService API"></a>ScheduledExecutorService API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  延迟执行Runnable任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟执行Callable任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按固定的频率period执行任务。initialDelay是第一次运行时的延迟时间。执行时间是 initialDelay+n*period. n是第几次执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次任务执行完后延迟时间delay后再次执行，执行时间是initalDelay+n*(任务执行时间+delay)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit);</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Executors创建</span></span><br><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//一秒执行一次</span></span><br><span class="line">ScheduledFuture&lt;?&gt; scheduledFuture = scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"> Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"> <span class="comment">//取消任务</span></span><br><span class="line">scheduledFuture.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>用于操作任务的计算结果和任务的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取消任务</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Param</span> mayInterruptIfRunning 是否中断执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 是否已经取消</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 是否已经执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞获取执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞获取执行结果，直到超时退出阻塞状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/fork-join框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/fork-join框架/" itemprop="url">fork/join框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-20T09:17:21+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Fork-Join框架简介"><a href="#Fork-Join框架简介" class="headerlink" title="Fork/Join框架简介"></a>Fork/Join框架简介</h1><p>fork/join是java7提供的任务并行执行的框架。fork就是将大任务分解成若干子任务，join就是将子任务的执行结果聚合成整个任务的结果。</p>
<p>Fork/Join框架通过两个类实现</p>
<ol>
<li>ForkJoinTask<br>ForkJoinTask负责分解任务和合并结果。通过实现compute方法，把任务分成多个子任务的ForkJoinTask，调用子任务的fork方法执行任务，再调用子任务的join方法等待子任务执行完。</li>
</ol>
<p>   通常不会直接继承ForkJoinTask而是使用其子类。<br>   RecursiveTask: 用于有返回结果的任务<br>   RecursiveAction: 用于没返回结果的任务</p>
<ol start="2">
<li>ForkJoinPool<br>ForkJoinPool用于执行ForkJoinTask。任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工作窃取算法是指某个线程从其他队列里窃取任务来执行。假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任</span><br><span class="line">务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>计算start-end之间所有数字的和。例子来自《java并发编程的艺术》<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">private</span>  <span class="keyword">static</span>  <span class="keyword">final</span>  <span class="keyword">int</span> THRESHOLD=<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.start=start;</span><br><span class="line">          <span class="keyword">this</span>.end=end;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">          <span class="comment">//分解的最小任务，达到最小任务就开始计算</span></span><br><span class="line">          <span class="keyword">if</span>(end-start&lt;THRESHOLD)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                  sum+=i;</span><br><span class="line">              &#125;</span><br><span class="line">          <span class="comment">//否则分解任务</span></span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//二分法分解任务</span></span><br><span class="line">              <span class="keyword">int</span> middle=(start+end)/<span class="number">2</span>;</span><br><span class="line">              CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">              CountTask rightTask = <span class="keyword">new</span> CountTask(middle+<span class="number">1</span>, end);</span><br><span class="line">              <span class="comment">//子任务fork开始执行，会再次调用子任务的compute，如果达不到最小任务会继续分解。（递归）</span></span><br><span class="line">              leftTask.fork();</span><br><span class="line">              rightTask.fork();</span><br><span class="line">              <span class="comment">//等待子任务完成，读取结果</span></span><br><span class="line">              sum+=leftTask.join();</span><br><span class="line">              sum+=rightTask.join();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> sum;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">      CountTask countTask = <span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">      ForkJoinPool pool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">      <span class="comment">//通过ForkJoinPool提交任务</span></span><br><span class="line">      ForkJoinTask&lt;Integer&gt; submit = pool.submit(countTask);</span><br><span class="line">      Integer integer = submit.get();</span><br><span class="line">      System.out.println(integer);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/java中的阻塞队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/java中的阻塞队列/" itemprop="url">java中的阻塞队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-18T20:34:59+08:00">
                2018-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阻塞队列是指支持阻塞添加和阻塞移除两种操作的队列.<br>java中提供了7种阻塞队列:<br>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<h1 id="阻塞队列的增删查方法"><a href="#阻塞队列的增删查方法" class="headerlink" title="阻塞队列的增删查方法"></a>阻塞队列的增删查方法</h1><table>
<thead>
<tr>
<th>处理方式/方法</th>
<th>抛出异常</th>
<th>返回值</th>
<th>阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="队列简介"><a href="#队列简介" class="headerlink" title="队列简介"></a>队列简介</h1><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue是一个由数组结构组成的有界阻塞队列。支持公平队列和非公平队列。会按照线程阻塞的顺序来让线程访问队列。默认是非公平队列，可以通过构造函数设置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity);</span><br><span class="line">ArrayBlockingQueue(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair);</span><br></pre></td></tr></table></figure></p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是一个由链表结构组成的有界阻塞队列。默认长度和最大长度都是Integer.MAX_VALUE，可以通过构造函数设置长度。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>PrioriityBlockingQueue是一个使用优先级队列实现的无界阻塞队列。队列中元素默认按照自然顺序的升序排序。相等的元素不能保证其顺序。<br>队列中的元素必须可以比较（即满足下面条件的其中之一）</p>
<ol>
<li><p>构造队列是传递Comparator，作为元素的比较器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityBlockingQueue(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                                 Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素自身实现Comparable接口</p>
</li>
</ol>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>DelayQueue支持延迟获取元素的无界阻塞队列，依据优先级队列PriorityQueue实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DelayQueue&lt;E extends Delayed&gt;</span><br></pre></td></tr></table></figure></p>
<p>DelayQueue中的元素必须实现Delayed。</p>
<h3 id="实现Delayed接口"><a href="#实现Delayed接口" class="headerlink" title="实现Delayed接口"></a>实现Delayed接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedElement</span> <span class="keyword">implements</span> <span class="title">Delayed</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">     <span class="keyword">private</span> String id;</span><br><span class="line">     <span class="comment">//1.构造函数设置延迟多久运行</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">DelayedElement</span><span class="params">(String id,<span class="keyword">long</span> time,TimeUnit unit)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.id=id;</span><br><span class="line">         <span class="keyword">this</span>.time=System.nanoTime()+TimeUnit.NANOSECONDS.convert(time,unit);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//2.获取还需要延迟多久</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> unit.convert(time-System.nanoTime(),TimeUnit.NANOSECONDS);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3. 比较，按time升序排序</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> diff = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">         <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="comment">//纳秒转成毫秒输出</span></span><br><span class="line">         <span class="keyword">return</span> String.format(<span class="string">"id:%s,seconds:%d"</span>,id,TimeUnit.SECONDS.convert(time,TimeUnit.NANOSECONDS));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DelayQueue delayQueue=<span class="keyword">new</span> DelayQueue();</span><br><span class="line"><span class="comment">//延迟5秒执行</span></span><br><span class="line">delayQueue.add(<span class="keyword">new</span> DelayedElement(<span class="string">"1"</span>,<span class="number">5</span>,TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">//延迟2秒执行</span></span><br><span class="line">delayQueue.add(<span class="keyword">new</span> DelayedElement(<span class="string">"2"</span>,<span class="number">2</span>,TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">//延迟1秒执行</span></span><br><span class="line">delayQueue.add(<span class="keyword">new</span> DelayedElement(<span class="string">"3"</span>,<span class="number">1</span>,TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">//阻塞等待</span></span><br><span class="line">System.out.println(delayQueue.take());</span><br><span class="line">System.out.println(delayQueue.take());</span><br><span class="line">System.out.println(delayQueue.take());</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br>id=3的最先运行，id=2的在id=3运行后1秒运行，id=1的在id=3运行后4秒运行。和预想结果一直。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">id:3,seconds:78285</span><br><span class="line">id:2,seconds:78286</span><br><span class="line">id:1,seconds:78289</span><br></pre></td></tr></table></figure>
<p>ScheduledThreadPoolExecutor实现延迟执行和固定周期执行依靠的DelayedWorkQueue与DelayQueue类似。ScheduledFutureTask是Delayed的实现。</p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue：一个不存储元素的阻塞队列。SynchronousQueue内部没有容器存储数据,每一个put操作，都需要等待一个take操作。否则不能再添加元素。<br>支持公平和非公平模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SynchronousQueue(<span class="keyword">boolean</span> fair)</span><br></pre></td></tr></table></figure>
<p>适用于生产者消费者模式的数据传递。</p>
<h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞队列。<br>LinkedTransferQueue实现了一个重要的接口TransferQueue，该接口含有下面几个重要方法：</p>
<ol>
<li>transfer(E e)：若当前存在一个正在等待获取的消费者线程，即立刻移交之；否则，会插入当前元素e到队列部，并且等待进入阻塞状态，到有消费者线程取走该元素。</li>
<li>tryTransfer(E e)：若当前存在一个正在等待获取的消费者线程（使用take()或者poll()函数），使用该方法即刻转移/传输对象元素e；若不存在，则返回false，并且不进入队列。这是一个不阻塞的操作。</li>
<li>tryTransfer(E e, long timeout, TimeUnit unit)：若当前存在一个正在等待获取的消费者线程，会立即传给它;否则将插入元素e到队列尾部，并且等待被消费者线程获取消费掉；若在指定的时间内元素e无法被消费者线程取，则返回false，同时该元素被移除。</li>
<li>hasWaitingConsumer()：判断是否存在消费者线程。</li>
<li>getWaitingConsumerCount()：获取所有等待获取元素的消费线程数量。</li>
</ol>
<h2 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h2><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。可以从队列的两端添加或者移除元素。因为有两个操作入口，也减少多线程入队时的竞争。增加了以First和Last结尾的操作函数，用于从头操作队列或者从尾部操作队列。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/EventListenerSupport实现事件监听/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/EventListenerSupport实现事件监听/" itemprop="url">EventListenerSupport实现事件监听</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-18T17:11:40+08:00">
                2018-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具类/" itemprop="url" rel="index">
                    <span itemprop="name">工具类</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>EventListenerSupport是apache lang3包提供用于处理事件监听的解决方案。</p>
<p>pom<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li><p>创建监听器接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onListener</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过接口创建EventListenerSupport</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventListenerSupport&lt;IListener&gt; eventListener = EventListenerSupport.create(IListener.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListener</span> <span class="keyword">implements</span> <span class="title">IListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向EventListenerSupport注册监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventListener.addListener(<span class="keyword">new</span> TestListener());</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件发生时,触发监听器.fire方法会返回IListener的代理类.运行IListener的方法,会通过代理允许所有注册监听器的相同方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventListener.fire().onListener();</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/14/CurrentHashMap源码解析（jdk1-8）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/CurrentHashMap源码解析（jdk1-8）/" itemprop="url">ConcurrentHashMap源码解析（jdk1.8）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-14T09:42:22+08:00">
                2018-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jdk源码/" itemprop="url" rel="index">
                    <span itemprop="name">jdk源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jdk8的ConcurrentHashMap改动非常大。放弃了之前segment锁，改用cas+synchronized来实现同步。</p>
<h2 id="常量含义"><a href="#常量含义" class="headerlink" title="常量含义"></a>常量含义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * table数组最大容量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> stactic <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量，是2的次幕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The largest possible (non-power of two) array size.</span></span><br><span class="line"><span class="comment"> * Needed by toArray and related methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default concurrency level for this table. Unused but</span></span><br><span class="line"><span class="comment"> * defined for compatibility with previous versions of this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载因子，用于判断是否需要扩容， 当哈希表中的条目数超出了加载因子与当前容量的乘积时.table长度扩容为原* 来的两倍。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转红黑树的阈值，链表长度超过这个值自动转为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树元素个数少于这个值，转回链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当桶中的bin被树化时最小的hash表容量。这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的</span></span><br><span class="line"><span class="comment"> * 4倍。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容线程每次最少要迁移16个hash桶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最多多少线程帮助扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以下是节点和hash值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// forwarding nodes的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 红黑树根节点的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// transient reservations的hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// 正常节点的最大hash值</span></span><br></pre></td></tr></table></figure>
<h2 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h2><p><strong>table</strong><br>用来存放Node节点数据的数组，默认为null，默认大小为16，每次扩容时大小总是2的幂次方；下文的table都是指这个属性</p>
<p><strong>nextTable</strong><br>扩容时新表，数组为table的两倍，扩容完毕会赋给table</p>
<p><strong>baseCount</strong><br>map的大小</p>
<p><strong>sizeCtl</strong><br>控制标识符，用来控制table初始化和扩容操作的，在不同的地方有不同的用途，其值也不同，所代表的含义也不同<br>负数代表正在进行初始化或扩容操作<br>-1代表正在初始化<br>-N 表示有N-1个线程正在进行扩容操作<br>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</p>
<p><strong>transferIndex</strong><br>表示已经分配给扩容线程的table数组索引位置。主要用来协调多个线程扩容。transferIndex初始化是指向table.length。当开始扩容时，首先要将transferIndex右移（以cas的方式修改 transferIndex=transferIndex-stride(要迁移hash桶的个数)），获取迁移任务。每个扩容线程都会通过for循环+CAS的方式设置transferIndex，因此可以确保多线程扩容的并发安全。</p>
<p><img src="https://github.com/wujiazhen2/pict/blob/master/jdk8%E6%BA%90%E7%A0%81/transferIndex.png?raw=true" alt="image"></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><strong>Node</strong><br>节点，保存key-value的数据结构；value字段和next用volatile修饰，保障可见性。读数据时不需要加锁。可以看到Node不支持setValue。修改值直接node.val=xxx修改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>TreeNode</strong><br>红黑树节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>TreeBin</strong><br>用于封装红黑树，持有红黑树根节点的引用。包含一个读写锁用于写线程等待读线程完成，再tree重新构造之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// 表示锁状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// 持有写锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// 等待写锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// 持有读锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ForwardingNode</strong><br>一个特殊的Node节点，hash值为-1(MOVED常量)，其中存储nextTable的引用。只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">  ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">      <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">  &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<h2 id="主要方法解析"><a href="#主要方法解析" class="headerlink" title="主要方法解析"></a>主要方法解析</h2><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>put方法调用了putVal方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>putVal方法关键代码解析</p>
<ol>
<li><p>计算hash值<br>spread方法通过高16位异或低16位来散列。因为后面计算table坐标时是采用 hash&amp;（length-1）的公式来计算。<br>也就是说只会保留低位，这样大大加大了出现hash冲突的概率。这里用高位^低位，增加低位的随机性，减少hash冲突的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tab==null时，先进行table的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">              tab = initTable();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 (table.length-1)&amp;hash算出脚标i,如果table脚标i的元素为null。说明不存在hash冲突。将key,val封装成Node,通过cas直接设置进table，跳出循环。cas失败说明其他线程修改了该脚标节点，重新开始循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点f是table中脚标为i，如果该节点hash==MOVE,说明该节点是ForwardingNode且其他线程正在对这个map进行扩容。当前线程也协助扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">               tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不是前面几种情况的话，就是说明存在hash冲突。将新节点加入以f为根节点的链表或红黑树。这里只需要锁住根节点，相比以前的分段锁粒度更小。红黑树用TreeBin对象封装，hash=-2。hash大于0即是链表。节点加入链表会记录一个链表长度binCount，如果binCount&gt;=TREEIFY_THRESHOLD,链表会向红黑树转化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addCount方法分两部分，一、更新baseCount,二、判断是否扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addCount(<span class="number">1L</span>, binCount);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *CounterCell是多线程的情况下辅助计算baseCount;</span></span><br><span class="line"><span class="comment">        *多线程添加时，通过随机在CounterCell数组中选一个来记录添加的map大小，减少多线程的竞争。</span></span><br><span class="line"><span class="comment">        *最后通过baseCount加上所有的CounterCell.value得出最终的baseCount。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">        <span class="comment">/*baseCount的更新</span></span><br><span class="line"><span class="comment">        * counterCells==null,通过cas更新baseCount。成功，更新完成。失败则进入if块处理。</span></span><br><span class="line"><span class="comment">        * counterCells!=null,直接进入if块处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//cas失败进入fullAddCount方法循环cas</span></span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//将CounterCell数组记录的值加入baseCount中</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断扩容</span></span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="comment">//s是上面计算的容量，s&gt;sizeCtl是扩容。sizeCtl一般是0.75*table.length,表示扩容阈值。</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="comment">/*sizeCtl&lt;0</span></span><br><span class="line"><span class="comment">                 *代表正在进行初始化或扩容操作</span></span><br><span class="line"><span class="comment">                 *-1代表正在初始化</span></span><br><span class="line"><span class="comment">                 *-N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//扩容任务已经全部分配或者扩容已经完成，则当前线程不需要再扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果已经有其他线程在执行扩容操作,sizeCtl+1，参与扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    <span class="comment">//扩容方法</span></span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩容transfer"><a href="#扩容transfer" class="headerlink" title="扩容transfer"></a>扩容transfer</h3><p>transfer是可以多线程进行的。通过给每个线程分配迁移<code>(将table中的hash桶迁移到新的nextTab中)</code>的hash桶，每个线程最少迁移16个hash桶，用transferIndex来同步。一个map扩容，要迁移的hash桶是原来的table长度。分配时从后面的分配起。从下图看出，每个线程分配的hash桶脚标范围是transferIndex-stride（线程迁移的hash桶个数）到transferIndex-1。分配完一个线程后，通过cas将transferIndex设置为transferIndex-stride。</p>
<p><img src="https://github.com/wujiazhen2/pict/blob/master/jdk8%E6%BA%90%E7%A0%81/concurrentHash%E6%89%A9%E5%AE%B9%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D%20.png?raw=true" alt="image"><br>线程迁移的hash桶个数最少是16，图中为了方便没画这么多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">      <span class="comment">//设置stride，stride是 分配给该线程迁移的hash桶个数，最小值是MIN_TRANSFER_STRIDE</span></span><br><span class="line">      <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">          stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">      <span class="comment">//nextTab为null时，这个第一个扩容的线程，初始化nextTab为原来table的2倍</span></span><br><span class="line">      <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">              Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">              nextTab = nt;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">              sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          nextTable = nextTab;</span><br><span class="line">          <span class="comment">//初始transferIndex</span></span><br><span class="line">          transferIndex = n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">      <span class="comment">//初始ForwardingNode节点，指向扩容的nextTab</span></span><br><span class="line">      ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">      <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">          <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">              <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">              <span class="comment">//</span></span><br><span class="line">              <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//如果transferIndex&lt;0,说明要迁移的hash桶都分配给线程执行了。</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  i = -<span class="number">1</span>;</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//cas修改，transferIndex。分配迁移hash桶任务。该线程负责迁移的hash桶脚标范围 bound-i</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                       (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                     nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">  </span><br><span class="line">                  <span class="comment">//该线程要迁移的hash桶的最小脚标</span></span><br><span class="line">                  bound = nextBound;</span><br><span class="line">                  <span class="comment">//该线程要迁移的hash桶的最大脚标</span></span><br><span class="line">                  i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// </span></span><br><span class="line">          <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">              <span class="keyword">int</span> sc;</span><br><span class="line">              <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                  nextTable = <span class="keyword">null</span>;</span><br><span class="line">                  table = nextTab;</span><br><span class="line">                  sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//</span></span><br><span class="line">              <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  <span class="comment">//所有线程都完成任务</span></span><br><span class="line">                  finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                  i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果table[i]==mull，设置ForwardingNode节点，用于占位。</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">              advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">              advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//迁移操作，锁住要迁移的hash桶</span></span><br><span class="line">              <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                  <span class="comment">/**</span></span><br><span class="line"><span class="comment">                  * hash桶中的节点rehash有两种情况。因为节点的key相同，索引hash值也相同。算脚标是hash&amp;</span></span><br><span class="line"><span class="comment">                  * (length-1),也就是只取hash值的前几位。扩容后length是之前的2倍。算脚标时，会取多一位。</span></span><br><span class="line"><span class="comment">                  * 所以根据hash&amp;(length-1)的结果，</span></span><br><span class="line"><span class="comment">                  * 1.如果最高位是0，则脚本和之前一样，移到原来位置。</span></span><br><span class="line"><span class="comment">                  * 2.如果最高位是1，新的脚标位置就是 length+原来脚标。</span></span><br><span class="line"><span class="comment">                  * 下面链表和红黑树都是这样将hash桶分成两份，设置在新表的对应位置。</span></span><br><span class="line"><span class="comment">                  */</span></span><br><span class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                      <span class="comment">//hash桶是链表结构</span></span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                          Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                              <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                              <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                  runBit = b;</span><br><span class="line">                                  lastRun = p;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                              ln = lastRun;</span><br><span class="line">                              hn = <span class="keyword">null</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              hn = lastRun;</span><br><span class="line">                              ln = <span class="keyword">null</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                              <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                              <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                  ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                          &#125;</span><br><span class="line">                          setTabAt(nextTab, i, ln);</span><br><span class="line">                          setTabAt(nextTab, i + n, hn);</span><br><span class="line">                          setTabAt(tab, i, fwd);</span><br><span class="line">                          advance = <span class="keyword">true</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//hash桶是红黑树</span></span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                          TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                          TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                          TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                          <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                              <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                              TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                  (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                              <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                      lo = p;</span><br><span class="line">                                  <span class="keyword">else</span></span><br><span class="line">                                      loTail.next = p;</span><br><span class="line">                                  loTail = p;</span><br><span class="line">                                  ++lc;</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">else</span> &#123;</span><br><span class="line">                                  <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                      hi = p;</span><br><span class="line">                                  <span class="keyword">else</span></span><br><span class="line">                                      hiTail.next = p;</span><br><span class="line">                                  hiTail = p;</span><br><span class="line">                                  ++hc;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                          ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                              (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                          hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                              (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                          setTabAt(nextTab, i, ln);</span><br><span class="line">                          setTabAt(nextTab, i + n, hn);</span><br><span class="line">                          setTabAt(tab, i, fwd);</span><br><span class="line">                          advance = <span class="keyword">true</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>get方法不需要加锁。因为Node的val是volatile修饰的，所以其他线程的修改对当前线程是可见的。</p>
<ol>
<li>先获取key对应的脚标i,table[i]==null,返回null。table[i]节点的key是否和key是否相等。相等则返回val。</li>
<li>table[i].hash&lt;0,则说明节点是TreeBin或者ForwardingNode节点，通过该节点的find方法找出key对应的节点。</li>
<li>不是以上情况则是链表，遍历链表找到key对应的节点值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/死锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/死锁/" itemprop="url">死锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T20:37:48+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>死锁是常见的线程活性问题。多个线程互相等待对方而导致永远暂停称为死锁。常见的死锁q情况是线程A持有锁L1的情况下申请锁L2,线程B持有锁L2申请锁L1。线程A等待锁L2释放，线程B等待锁L1释放，从而互相等待永远暂停。</p>
<h1 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h1><ol>
<li>资源互斥,资源同时只能被一个线程占用。</li>
<li>资源不可抢夺，资源被一个线程占用时，其他线程无法抢夺。</li>
<li>占用并等待资源，线程持有资源，并申请另外的资源而进入等待时。不会释放现有资源。</li>
<li>循环等待资源，线程A持有锁L1的情况下申请锁L2,线程B持有锁L2申请锁L1。线程A等待锁L2释放，线程B等待锁L1释放。A持有L1等L2,B持有L2等L1 这就是循环等待。</li>
</ol>
<h1 id="哲学家用餐问题"><a href="#哲学家用餐问题" class="headerlink" title="哲学家用餐问题"></a>哲学家用餐问题</h1><p>哲学家用餐问题是经典的死锁问题。一群哲学家围着一个大圆桌坐下，每个哲学家面前都有一个碗和一根筷子。哲学家要么思考要么吃饭。哲学家吃饭时总是先拿起左手边的筷子再拿起右手边的筷子。只有拿到2根筷子的哲学家可以吃饭。哲学家吃饭吃着会放下筷子，再次思考。</p>
<p>将问题简化，假设只有2个哲学家。哲学家p1想吃饭，先拿起他左边的筷子c1。这时哲学家p2也想吃饭,拿起他左边的筷子c2。哲学家相当于线程，筷子相当于锁。这样就进入死锁状态。<br><img src="https://github.com/wujiazhen2/pict/blob/master/thread/%E5%93%B2%E5%AD%A6%E5%AE%B6.png?raw=true" alt="image"></p>
<h2 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟"></a>代码模拟</h2><h3 id="哲学家抽象类"><a href="#哲学家抽象类" class="headerlink" title="哲学家抽象类"></a>哲学家抽象类</h3><p>定义哲学家的吃饭，思考动作和 身份标识id，左右筷子属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPhilosopher</span>  <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">protected</span> Chopsticks left;</span><br><span class="line">    <span class="keyword">protected</span> Chopsticks right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractPhilosopher</span><span class="params">(<span class="keyword">int</span> id,Chopsticks left,Chopsticks right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        <span class="keyword">this</span>.left=left;</span><br><span class="line">        <span class="keyword">this</span>.right=right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//哲学家不是在思考，就是在吃饭</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            think();</span><br><span class="line">            eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="keyword">void</span>  <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">think</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s  thinking"</span>,<span class="keyword">this</span>.toString()));</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">2</span>)*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doEat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s eating"</span>,<span class="keyword">this</span>.toString()));</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">2</span>)*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> String.format(<span class="string">"Philosopher%d"</span>,<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="筷子类"><a href="#筷子类" class="headerlink" title="筷子类"></a>筷子类</h3><p>筷子类充当锁对象，获取锁相当于拿起筷子，释放锁相当于放下筷子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chopsticks</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chopsticks</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Chopsticks%d"</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="哲学家实现类"><a href="#哲学家实现类" class="headerlink" title="哲学家实现类"></a>哲学家实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockPhilosopher</span> <span class="keyword">extends</span> <span class="title">AbstractPhilosopher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLockPhilosopher</span><span class="params">(<span class="keyword">int</span> id, Chopsticks left, Chopsticks right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//拿起左边筷子</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.left)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s拿起%s"</span>,<span class="keyword">this</span>.toString(),<span class="keyword">this</span>.left.toString()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为了使死锁发生频率高点，在这里等下哲学家2获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.right)&#123;</span><br><span class="line">                <span class="comment">//拿起右边筷子</span></span><br><span class="line">                System.out.println(String.format(<span class="string">"%s拿起%s"</span>,<span class="keyword">this</span>.toString(),<span class="keyword">this</span>.right.toString()));</span><br><span class="line">                <span class="keyword">this</span>.doEat();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">         Chopsticks c1 = <span class="keyword">new</span> Chopsticks(<span class="number">1</span>);</span><br><span class="line">         Chopsticks c2 = <span class="keyword">new</span> Chopsticks(<span class="number">2</span>);</span><br><span class="line">         <span class="comment">//筷子c1是哲学家p1的左筷子，c2是p1的右筷子</span></span><br><span class="line">         DeadLockPhilosopher p1 = <span class="keyword">new</span> DeadLockPhilosopher(<span class="number">1</span>,c1,c2);</span><br><span class="line">          <span class="comment">//筷子c2是哲学家p2的左筷子，c1是p2的右筷子</span></span><br><span class="line">         DeadLockPhilosopher p2 = <span class="keyword">new</span> DeadLockPhilosopher(<span class="number">2</span>,c2,c1);</span><br><span class="line">         p1.start();</span><br><span class="line">         p2.start();</span><br><span class="line"></span><br><span class="line">         p1.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Philosopher1  thinking</span><br><span class="line">Philosopher2  thinking</span><br><span class="line">Philosopher2拿起Chopsticks2</span><br><span class="line">Philosopher1拿起Chopsticks1</span><br></pre></td></tr></table></figure></p>
<p>哲学家p2拿起了筷子c2,哲学家p1拿起了筷子c1。产生死锁。</p>
<h1 id="避免死锁的解决方法"><a href="#避免死锁的解决方法" class="headerlink" title="避免死锁的解决方法"></a>避免死锁的解决方法</h1><p>死锁的解决方法可以从死锁的产生条件入手。只要消除死锁四个必要条件之一就可以避免死锁。</p>
<h2 id="粗粒锁法"><a href="#粗粒锁法" class="headerlink" title="粗粒锁法"></a>粗粒锁法</h2><p>通过一个大的锁来替代多个细粒度的锁。由于只有一个锁，死锁的必要条件占用并等待资源和循环等待资源都不成立。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigLogPhilosopher</span> <span class="keyword">extends</span> <span class="title">AbstractPhilosopher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  <span class="keyword">static</span> Object GLOBAL_LOCK=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigLogPhilosopher</span><span class="params">(<span class="keyword">int</span> id, Chopsticks left, Chopsticks right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (GLOBAL_LOCK)&#123;</span><br><span class="line">            <span class="comment">//拿起左边</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"%s拿起%s"</span>,<span class="keyword">this</span>.toString(),<span class="keyword">this</span>.left.toString()));</span><br><span class="line">            <span class="comment">//拿起右边筷子</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"%s拿起%s"</span>,<span class="keyword">this</span>.toString(),<span class="keyword">this</span>.right.toString()));</span><br><span class="line">            <span class="keyword">this</span>.doEat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>粗粒锁的缺点是降低了并发，浪费资源。如果有4个哲学家的情况下，一个哲学家吃饭，还剩下2根筷子可以给一个哲学家同时用餐。<br>但是用粗粒锁的方法同时只能一个哲学家吃饭。</p>
<h2 id="锁排序法"><a href="#锁排序法" class="headerlink" title="锁排序法"></a>锁排序法</h2><p>锁排序是给锁进行排序，所有线程申请锁都按排好的顺序。从而消除循环等待条件。</p>
<p>如哲学家问题中，给筷子排序，每次哲学家不按照左右顺序来拿筷子。而是都拿id小的筷子再拿大的。<br>所以哲学家p1,p2都会先拿筷子c1。当哲学家p1拿到筷子c1后，哲学家p2获取不到锁进入阻塞。死锁不会发送。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortLockPhilosopher</span> <span class="keyword">extends</span> <span class="title">DeadLockPhilosopher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SortLockPhilosopher</span><span class="params">(<span class="keyword">int</span> id, Chopsticks left, Chopsticks right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id, left, right);</span><br><span class="line">        <span class="keyword">if</span>(left.getId()&gt;right.getId())&#123;</span><br><span class="line">            <span class="keyword">this</span>.left=right;</span><br><span class="line">            <span class="keyword">this</span>.right=left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Chopsticks c1 = <span class="keyword">new</span> Chopsticks(<span class="number">1</span>);</span><br><span class="line">    Chopsticks c2 = <span class="keyword">new</span> Chopsticks(<span class="number">2</span>);</span><br><span class="line">    DeadLockPhilosopher p1 = <span class="keyword">new</span> SortLockPhilosopher(<span class="number">1</span>,c1,c2);</span><br><span class="line">    DeadLockPhilosopher p2 = <span class="keyword">new</span> SortLockPhilosopher(<span class="number">2</span>,c2,c1);</span><br><span class="line">    p1.start();</span><br><span class="line">    p2.start();</span><br><span class="line"></span><br><span class="line">    p1.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用tryLock-long-TimeUnit"><a href="#用tryLock-long-TimeUnit" class="headerlink" title="用tryLock(long,TimeUnit)"></a>用tryLock(long,TimeUnit)</h2><p>第三种方法是通过tryLock(long,TimeUnit),固定时间内获取不了锁就获取失败返回false。哲学家问题中，可以在超时获取不到锁的情况下，将本来就持有的锁放下，即可消除占有并等待资源条件，避免死锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/懒加载中的DCL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/懒加载中的DCL/" itemprop="url">懒加载中的DCL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T14:44:40+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>java中经常会使用延迟一些高开销对象的初始化过程，等到使用再加载，称之为懒加载。</p>
<h1 id="单例中懒汉式"><a href="#单例中懒汉式" class="headerlink" title="单例中懒汉式"></a>单例中懒汉式</h1><p>下面时单例中的懒汉式代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;   <span class="comment">//1</span></span><br><span class="line">        instance=<span class="keyword">new</span> Instance();  <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    retrun instance;  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这代码子是典型的 check-then-act的模式，在多线程情况下存在多线程安全问题。例如线程1执行完步骤1还未执行2时，让出执行权。线程2进来会将instance初始化。线程1唤醒时会再次初始化对象，破坏了单例。</p>
<h2 id="DCL实现懒汉式"><a href="#DCL实现懒汉式" class="headerlink" title="DCL实现懒汉式"></a>DCL实现懒汉式</h2><p>为了解决线程安全问题，getInstance方法要加锁。但是根据getInstance方法的作用。锁再instance对象初始化完毕后就没作用。 所以采用DCL (Double-Checked Locking)双层检查锁的方式。通过第一次检查如果instance初始化了就直接跳过加锁代码，返回instance。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Instance&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Instance</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  <span class="comment">//1</span></span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;   <span class="comment">//2</span></span><br><span class="line">                    instance=<span class="keyword">new</span> Instance();  <span class="comment">//3</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;  <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DCL实现懒汉式存在问题"><a href="#DCL实现懒汉式存在问题" class="headerlink" title="DCL实现懒汉式存在问题"></a>DCL实现懒汉式存在问题</h2><p>这种写法看上去解决了线程安全，也兼顾了效率。其实不然，这种代码会导致getInstanceh返回一个没有初始化完成的Instance对象。</p>
<p>问题出现在第三步，instance=new Instance()这行代码可以用下面三行伪代码表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menory=allocate();    //1.分配内存</span><br><span class="line">ctorInstance(menory); //2.初始化</span><br><span class="line">instance=menory;      //3.赋值给instance</span><br></pre></td></tr></table></figure></p>
<p>intra-thread semantics（线程内语义）允许那些在单线程内，不会改变单线程程序执行结果的重排序。重排序后的顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menory=allocate();    //1.分配内存</span><br><span class="line">instance=menory;      //2.赋值给instance</span><br><span class="line">ctorInstance(menory); //3.初始化</span><br></pre></td></tr></table></figure></p>
<p>对单线程来说只要Instance初始化在该线程访问Instance对象之前都是不会改变执行结果。</p>
<p>注意:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">happens-before的锁定规则是“一个unLock操作先行发生于后面对同一个锁的lock操作”并不会禁止锁内部的重排序。</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，如果线程1执行步骤2 <code>instance=menory</code>后，线程2获取执行权判断<code>if(instance==null)</code>时，instance不为null,线程2将会返回一个未初始化完成的instance对象。</p>
<table>
<thead>
<tr>
<th>执行顺序</th>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>分配内存</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>设置instance指向内存空间</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>判断instance是否为null</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>初次访问Instance对象</td>
</tr>
<tr>
<td>5</td>
<td>初始化Instance对象</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>初次访问Instance对象</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用volatile-DCL"><a href="#使用volatile-DCL" class="headerlink" title="使用volatile+DCL"></a>使用volatile+DCL</h3><p>该问题产生的原因是2和3的重排序导致的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menory=allocate();    //1.分配内存</span><br><span class="line">instance=menory;      //2.赋值给instance</span><br><span class="line">ctorInstance(menory); //3.初始化</span><br></pre></td></tr></table></figure></p>
<p>那么解决方案可以是禁止2和3的重排序。</p>
<p>通过将instance变量设置为volatile变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Instance&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Instance</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span>  Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  </span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;   </span><br><span class="line">                    instance=<span class="keyword">new</span> Instance();  </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>volatile变量会通过内存屏障来禁止重排序。</p>
<h3 id="通过类加载实现"><a href="#通过类加载实现" class="headerlink" title="通过类加载实现"></a>通过类加载实现</h3><p>jvm类加载后，执行类初始化时,会去获取锁同步多线程初始化类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span>()</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">InstanceHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span>  Instance  instance= <span class="keyword">new</span> Instance();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  InstanceHolder.instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="执行图"><a href="#执行图" class="headerlink" title="执行图"></a>执行图</h4><p><img src="https://raw.githubusercontent.com/wujiazhen2/pict/master/thread/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B.png" alt="image"></p>
<p>这里初始化过程虽然也发生了重排序，但是对于线程2来说这个操作是原子性的。线程2只能看到操作未开始或者已经结束之后。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/FileAlterationMonitor实现文件监听/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/FileAlterationMonitor实现文件监听/" itemprop="url">FileAlterationMonitor实现文件监听</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T10:16:58+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具类/" itemprop="url" rel="index">
                    <span itemprop="name">工具类</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="文件监听组件"><a href="#文件监听组件" class="headerlink" title="文件监听组件"></a>文件监听组件</h4><p>Apacha common.io2.0提供了监听文件变化的功能。 </p>
<p>功能由三个组件组成。</p>
<ol>
<li><p>监听器 FileAlterationListener</p>
<p> 用于实现文件改变时触发的行为。</p>
</li>
<li><p>观察者 FileAlterationObserver</p>
<p> 用于观察文件的改变，通知注册的监听器执行相应的事件。</p>
</li>
<li><p>监视器 FileAlterationMonitor</p>
<p> 通过一线程，每间隔一段时间调用一次注册的观察者检查文件。</p>
</li>
</ol>
<p>maven依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="FileAlterationListener"><a href="#FileAlterationListener" class="headerlink" title="FileAlterationListener"></a>FileAlterationListener</h4><p>通过继承FileAlterationListenerAdaptor,覆盖相应事件方法。这里只重写了文件改变。还有其他事件可以查看FileAlterationListener接口看下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileAlterationReload</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"文件改变"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         <span class="comment">//检查classpath下properties文件夹下的properties文件。</span></span><br><span class="line">         FileAlterationObserver fileAlterationObserver = <span class="keyword">new</span> FileAlterationObserver(Demo.class.getClassLoader().getResource(<span class="string">"properties"</span>).getPath(),<span class="keyword">new</span> PropertiesFileFilter());</span><br><span class="line">         </span><br><span class="line">         FileAlterationListener fileAlterationListener =<span class="keyword">new</span> FileAlterationReload();</span><br><span class="line">         <span class="comment">//注册监听器</span></span><br><span class="line">         fileAlterationObserver.addListener(fileAlterationListener);</span><br><span class="line">         FileAlterationMonitor fileAlterationMonitor = <span class="keyword">new</span> FileAlterationMonitor();</span><br><span class="line">         <span class="comment">//注册观察者</span></span><br><span class="line">         fileAlterationMonitor.addObserver(fileAlterationObserver);</span><br><span class="line">         <span class="comment">//启动监听</span></span><br><span class="line">         fileAlterationMonitor.start();</span><br><span class="line">         <span class="comment">//让主线程别这么快结束。</span></span><br><span class="line">         Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改properties文件夹下的properties文件时，会输出 文件改变。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>可以用于实现配置文件的热部署</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/synchronized原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wujiazhen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序猿的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/synchronized原理/" itemprop="url">synchronized原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T10:06:01+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>synchronized关键字是jdk提供用于实现内部锁。</p>
<h4 id="synchronized实现机制"><a href="#synchronized实现机制" class="headerlink" title="synchronized实现机制"></a>synchronized实现机制</h4><p>synchronized代码块通过加锁的方式，只有获取到锁的线程才可以进去改代码块。使多个线程排队运行改代码块，保证代码块的原子性（对其他线程来说。只能看到别的线程还未执行或执行完毕的状态）。</p>
<h5 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h5><ol>
<li>Monitor对象是jvm实现的，c++中的对象。</li>
<li>每个对象内部都有一个唯一的monitor,monitor的获取是互斥的。</li>
<li>synchronized通过monitor来实现互斥。</li>
<li>monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</li>
</ol>
<h5 id="javap反汇编分析"><a href="#javap反汇编分析" class="headerlink" title="javap反汇编分析"></a>javap反汇编分析</h5><p>通过javap将下列代码反汇编<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       i++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test1用synchronized代码块，通过monitorenter获取锁，执行完后用monitorexit释放锁。<br><img src="https://raw.githubusercontent.com/wujiazhen2/pict/master/thread/synchronized%E6%B1%87%E7%BC%96.png" alt="image"></p>
<p>test2是synchronized方法，jvm通过ACC_SYNCHRONIZED标志，内部实现。<br><img src="https://raw.githubusercontent.com/wujiazhen2/pict/master/thread/synchronized2.png" alt="image"></p>
<p>无论是monitorenter/monitorexit还是ACC_SYNCHRONIZED，最终都是通过获取锁对象的monitor实现互斥。进入synchronized代码块前会通过monitorenter来获取monitor对象。获取失败的线程进入同步队列中等待。获取monitor对象的线程执行完后通过monitorexit指令来释放锁。释放锁会通知同步队列中阻塞的线程出队列再次申请锁。<br><img src="https://raw.githubusercontent.com/wujiazhen2/pict/master/thread/synchronized%E5%92%8C%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6.png" alt="image"></p>
<h4 id="Synchronized-1-6的优化"><a href="#Synchronized-1-6的优化" class="headerlink" title="Synchronized 1.6的优化"></a>Synchronized 1.6的优化</h4><p>锁的强度分四种级别，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。他们会随着竞争的激烈而逐渐升级。</p>
<p>锁的相关信息存在对象的对象头的Mark Word：<br>Mark Word是hotSpot虚拟机的对象的对象头中的一部分，用于存储对象滋生运行时数据，如hashcode,GC分代年龄、锁状态标志，线程持有锁,偏向线程id,偏向时间戳等信息。</p>
<p><strong>Mark Word结构</strong><br><img src="https://raw.githubusercontent.com/wujiazhen2/pict/master/thread/MarkWord.png" alt="image"></p>
<h5 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h5><p>线程的阻塞和唤醒需要cpu从用户态切换成内核态，给cpu造成很大的负担。而往往一个线程从阻塞到唤醒只经历很短的一段时间，所以引入自旋锁。通过无意义的循环进行等待锁释放，而不会立刻进入阻塞，这就是自旋。因为自旋是会消耗cpu的，所以要有个自旋次数限制，达到自旋次数还未获取锁就进入阻塞。适应自旋锁会根据自旋获取锁的成功率来调整自旋次数，如果获取锁成功率高会调高自旋次数，否则反之。</p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是JIT编译器借助逃逸分析技术分析锁对象是否只能给一个线程访问而没发布到其他线程，锁消除就是在JIT生成动态字节码时消除moniterenter(申请锁)和moniterexit（释放锁）两个字节码指令。</p>
<p>注意：锁消除并不意味着可以随意加锁，JIT只会对执行频率足够多的地方进行优化。</p>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>使用锁时，我们会尽力将锁的范围缩小，只在操作共享变量时同步以减小锁竞争的范围。但是如果一系列的连续加锁解锁操作，频繁的获取释放锁可能会导致不必要的性能损耗，所以就是将多个连续的加锁、解锁操作（锁对象相同）连接在一起，扩展成一个范围更大的锁，这就是锁粗化。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>大部分锁并没有被争用，且在其生命周期内也许至多被一个线程持有。所以一个内部锁第一次被获取时，会将Mark Word的偏向线程设为获取锁的线程，是否偏向锁标志设为1。线程只要判断偏向线程是否是当前线程，是则说明当前线程获取锁了。否则会通过cas设置Mark work。失败的话，则说明存在争用，撤销偏向锁，锁升级为轻量锁</p>
<h6 id="偏向锁获取和撤销流程"><a href="#偏向锁获取和撤销流程" class="headerlink" title="偏向锁获取和撤销流程"></a>偏向锁获取和撤销流程</h6><ol>
<li>获取对象头的Mark Word；</li>
<li>判断Mark Word偏向锁标志位是否为1,锁标志位为 01。否，则cas竞争锁。是的话，该锁是偏向锁进入（3）;</li>
<li>判断Mark Work中的线程ID是否设置，没设置则进入步骤（4）；如果指向当前线程，则执行同步代码块；如果指向其它线程，进入步骤（5）；</li>
<li>通过CAS原子指令设置Mark Word的线程ID为当前线程ID，如果执行CAS成功，则执行同步代码块，否则进入步骤（5）；</li>
<li>如果执行CAS失败，表示当前存在多个线程竞争锁，当达到全局安全点（safepoint），获得偏向锁的线程被挂起，撤销偏向锁，并升级为轻量级，升级完成后被阻塞在安全点的线程继续执行同步代码块；（偏向锁会一直被持有<code>Mark Word中的ThreadId一直指向获取锁的线程</code>,直到其他线程来竞争锁）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wujiazhen2/pict/master/thread/%E5%81%8F%E5%90%91%E9%94%81.png" alt="image"></p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>引入轻量级锁的主要目的是在没有多线程竞争的前提下，通过cas减少重量锁的使用。轻量锁依据是大部分锁再同步周期内不存在竞争。</p>
<h6 id="轻量锁获取和撤销流程"><a href="#轻量锁获取和撤销流程" class="headerlink" title="轻量锁获取和撤销流程"></a>轻量锁获取和撤销流程</h6><ol>
<li>jvm会在进入同步块前会在当前线程的栈帧创建用于存储锁记录的空间。</li>
<li>轻量锁进入同步代码块前会将mark work复制到锁记录中，通过cas将对象头中的Mark Word替换为指向锁记录的指针。cas成功则获取锁，将锁标志位改成00表示轻量锁。失败则尝试自旋获取锁。</li>
<li>在执行完代码块释放锁时会通过cas将Mark Word替换回对象头。cas成功则释放锁。如果失败则说明同步周期内存在竞争，锁升级为重量锁。</li>
</ol>
<p>因为自旋会消耗cpu，所以轻量锁一旦升级为重量锁就不会恢复。<br><img src="https://raw.githubusercontent.com/wujiazhen2/pict/master/thread/%E8%BD%BB%E9%87%8F%E9%94%81.png" alt="image"></p>
<h5 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h5><p>重量锁就是通过Monitor实现的互斥锁。monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wujiazhen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wujiazhen2" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wujiazhen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
